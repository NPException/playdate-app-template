{:min-bb-version "1.3.185"
 :tasks
 {:requires ([clojure.string :as str]
             [babashka.fs :as fs])

  ;; Script Initialization
  :init
  (do (def config {
                   ; Name of the zip file when the `build-release` task is called.
                   ; Any key from the pdxinfo file can be used as placeholder.
                   :release-name     "${name} v${version}_b${buildNumber}"
                   ; Directory where all code and assets are located
                   :sources          "./src/"
                   ; Directory relative to `:sources` where Fennel macro modules are placed.
                   ; Fennel files within this directory will not be compiled directly.
                   ; (but other file types will still be copied to `:compiled-sources`)
                   :fennel-macros    "macros/"
                   ; Directory where the compiled Lua and other copied files will be put.
                   ; This is then used as the input directory for the Playdate compiler.
                   ; If there are no `.fnl` files this is unused and `pdc` uses `:sources` directly.
                   :compiled-sources "./compiled-src/"
                   ; Lua file that is the program's entry point.
                   ; (note that a "main.fnl" file will be compiled to "main.lua")
                   :main-file        "main.lua"
                   ; Directory where the Playdate compiler will output the final PDX app.
                   :build-output     "./builds/"})

      ; detect the operating system, so it can be used where system specific code is necessary
      (def OS (let [os-name (str/lower-case (System/getProperty "os.name"))]
                (cond
                  (str/includes? os-name "windows") :windows
                  (str/includes? os-name "mac") :mac
                  :else :linux)))

      (def src-dir (fs/canonicalize (fs/path (:sources config))))
      (def macros-dir (fs/path src-dir (:fennel-macros config))))


  ;; Available Babashka Tasks

  -pdxinfo
  {:doc  "Prepares reading from and writing to the pdxinfo file"
   :task (let [pdxinfo-path (fs/path src-dir "pdxinfo")
               pdxinfo-lines (atom (->> (fs/read-all-lines pdxinfo-path)
                                     (mapv (fn [line]
                                             (if (or (str/blank? line) (str/starts-with? line "#"))
                                               line
                                               (str/split line (re-pattern "=") 2))))))]

           ; function to read a value from the pdxinfo file
           (defn pdxinfo [key]
             (let [value (->> (deref pdxinfo-lines)
                           (filter (fn [[k v]] (= k key)))
                           first
                           second)]
               (when-not value
                 (println (str "Tried to read `" key "` from pdxinfo file, but they key is missing in the file."))
                 (System/exit 1))
               value))

           ; function to change a value
           (defn pdxinfo-set! [key value]
             (assert (string? value))
             ; first set the new value in memory
             (->> (swap! pdxinfo-lines
                    (fn [lines]
                      (mapv (fn [[k _ :as line]]
                              (if (= key k)
                                [key value]
                                line))
                        lines)))
               ; store the new lines to the file
               (map (fn [line]
                      (if (vector? line)
                        (str (first line) "=" (second line))
                        line)))
               (fs/write-lines pdxinfo-path))))}

  -pdx-name
  {:depends [-pdxinfo]
   :task    (def pdx-name (str (pdxinfo "bundleID") ".pdx"))}


  clean-compiled
  {:doc   "Deletes the directory generated via the `compile` task."
   :enter (println (str "Deleting `" (:compiled-sources config) "`"))
   :task  (fs/delete-tree (:compiled-sources config))}


  -fennel-project?
  {:doc  "Walk the directory. When finding a fennel file, checks if the `fennel` command exists."
   :task (do (defn fennel-file? [path]
               (= "fnl" (fs/extension path)))
             (def fennel-project? false)
             (fs/walk-file-tree src-dir
               {:pre-visit-dir
                (fn [path attrs]
                  ; we don't care about .fnl files within the macros directory, since those aren't compiled anyway
                  (if (fs/same-file? macros-dir path)
                    :skip-subtree
                    :continue))
                :visit-file
                (fn [path attrs]
                  (if-not (fennel-file? path)
                    :continue
                    (do (when-not (fs/which "fennel")
                          (println "`fennel` is not available to this script. Make sure it is available on your PATH.\nIf you don't have Fennel yet, you can get the binary at https://fennel-lang.org/setup#downloading-a-fennel-binary")
                          (System/exit 1))
                        (def fennel-project? true)          ; yucky reassignment, but it works nicely
                        :terminate)))}))}


  compile
  {:doc     "Compiles all Fennel files using `fennel` and copies all other files to the `:compiled-sources` directory. Does nothing if there are no `.fnl` files in the project."
   :depends [clean-compiled -fennel-project?]
   :task    (when fennel-project?
              (println "Compiling Fennel")
              (fs/create-dirs (:compiled-sources config))
              (fs/walk-file-tree src-dir
                {:visit-file
                 (fn [path attrs]
                   (let [rel-path-str (str (fs/relativize src-dir path))]
                     (if (fennel-file? path)
                       ; compile fennel file to lua, but ignore macro files
                       (if (fs/starts-with? path macros-dir)
                         :continue
                         ; TODO: check on linux if this shell command works fine or needs a specific impl
                         (let [compiled-lua (:out (shell
                                                    {:dir (:sources config), :out :string}
                                                    "fennel" "--compile" rel-path-str))]
                           (if-not compiled-lua
                             :terminate
                             (let [[path-without-extension] (fs/split-ext rel-path-str)
                                   lua-file (fs/path (:compiled-sources config) (str path-without-extension ".lua"))]
                               (fs/create-dirs (fs/parent lua-file))
                               (fs/write-bytes lua-file (.getBytes (str compiled-lua)))
                               :continue))))
                       ; copy any non-fennel files
                       (let [target-path (fs/path (:compiled-sources config) rel-path-str)]
                         (fs/create-dirs (fs/parent target-path))
                         (fs/copy path target-path {:replace-existing true})
                         :continue))))}))}


  -pdx-output-path
  {:depends [-pdx-name]
   :task    (def pdx-output-path (str (fs/canonicalize (fs/path (:build-output config) pdx-name))))}


  clean
  {:doc     "Removes the PDX build output directory"
   :depends [-pdx-output-path]
   :enter   (println (str "Deleting `" (str (fs/relativize (fs/cwd) pdx-output-path)) "`"))
   :task    (fs/delete-tree pdx-output-path)}


  -pd-sdk
  {:doc  "Checks if the Playdate SDK path is known"
   :task (do (def pd-sdk-path (System/getenv "PLAYDATE_SDK_PATH"))
             (when-not pd-sdk-path
               (println "`PLAYDATE_SDK_PATH` environment variable is not set.\nIf you don't have the Playdate SDK yet, you can get it at https://play.date/dev/")
               (System/exit 1)))}


  create-pdx
  {:doc     "Builds all files in the `:compiled-sources` directory into a Playdate PDX app."
   :depends [clean -fennel-project? -pd-sdk]
   :enter   (println "Building PDX app")
   :task    (do (fs/create-dirs (:build-output config))
                (shell
                  {:dir (if fennel-project?
                          (:compiled-sources config)
                          (:sources config))}
                  (str pd-sdk-path "/bin/pdc") "-m" (:main-file config) pdx-output-path))}


  -last-build-file
  {:task (def last-build-file (fs/path (:build-output config) "last-build"))}


  -bump-build-nr
  {:doc     "Increments the `buildNumber` in the pdxinfo file if files in `:sources` have changed since the last `build`."
   :depends [-pdxinfo -last-build-file]
   :enter   (println "Incrementing `buildNumber`")
   :task    (when (seq (fs/modified-since last-build-file src-dir))
              (let [build-nr (parse-long (pdxinfo "buildNumber"))]
                (pdxinfo-set! "buildNumber" (str (inc build-nr)))))}


  build
  {:doc     "Increments the `buildNumber` in pdxinfo (if sources changes since last build), compiles Fennel (if necessary) and builds everything into a Playdate PDX app."
   :depends [-last-build-file -bump-build-nr compile create-pdx]
   :task    (fs/write-lines last-build-file [(str (System/currentTimeMillis))])}


  copy-pdx-to-sim
  {:doc     "Copies the PDX app to the Playdate simulator's games directory, so it can be selected in the simulator's menu."
   :depends [-pdx-output-path -pd-sdk]
   :enter   (println "Copying app to simulator")
   :task    (let [target-path (fs/path pd-sdk-path "Disk/Games/User/" pdx-name)] ; TODO: check if this path works the same under Linux
              (fs/delete-tree target-path)
              (fs/copy-tree pdx-output-path target-path))}


  start-sim
  {:doc     "Starts the Playdate simulator with the PDX app in the build output directory"
   :depends [-pdx-output-path -pd-sdk]
   :enter   (println "Starting Playdate Simulator")
   :task    (let [sim-path (str (fs/path pd-sdk-path "bin/PlaydateSimulator"))] ; TODO: check if this path works the same under Linux
              (shell sim-path pdx-output-path))}


  build-and-sim
  {:doc     "Calls the `build` task and then starts the Playdate simulator."
   :depends [build start-sim]}


  build-copy-sim
  {:doc     "Calls the `build` and `copy-pdx-to-sim` tasks, then starts the Playdate Simulator."
   :depends [build copy-pdx-to-sim start-sim]}


  build-release
  {:doc     "Calls `build` and puts the resulting PDX app in a zip."
   :depends [build]
   :task    (let [build-path (fs/path (:build-output config))
                  pdx-path (fs/path build-path pdx-name)
                  dirs (loop [processed []
                              unprocessed [pdx-path]]
                         (if (empty? unprocessed)
                           processed
                           (recur
                             (concat processed unprocessed)
                             (fs/list-dirs unprocessed fs/directory?))))
                  entries (fs/list-dirs dirs (complement fs/directory?))
                  name-replacer (fn [[full-match key]]
                                  (pdxinfo key))
                  zip-name (str/replace (:release-name config) (re-pattern "\\$\\{([^\\}]+)\\}") name-replacer)
                  zip-path (fs/path build-path (str zip-name ".pdx.zip"))]
              ; NOTE: For some reason babashka will create an empty file in the zip alongside each folder if I just pass in the root folder I want to zip up
              (fs/zip zip-path entries
                ; store paths relative to builds folder
                {:path-fn (fn [path]
                            (str (fs/relativize build-path path)))}))}

  }}

; TODO: - add github action to trigger release (for latest tag on main?)
